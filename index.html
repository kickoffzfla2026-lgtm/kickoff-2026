<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Acceso</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --card:#121a2b;
      --card2:#0c1326;
      --text:#e8ecff;
      --muted:rgba(232,236,255,.75);
      --border:#2a3553;
      --primary:#4b7dff;
      --danger:#ffb3b3;
      --ok:#b7ffc9;
    }

    body{
      font-family:system-ui,sans-serif;
      display:flex;
      min-height:100vh;
      align-items:center;
      justify-content:center;
      background:var(--bg);
      color:var(--text);
      padding:24px;
      margin:0;
      overflow-x:hidden;
    }

    /* Capas */
    #particles{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      z-index:0;
      pointer-events:none;
      opacity:0.9;
    }
    #radarWrap{
      position:fixed;
      top:14px; right:14px;
      width:160px; height:160px;
      z-index:20;
      pointer-events:none;
      opacity:0.95;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,.35));
    }
    #radarLabel{
      position:absolute;
      bottom:-18px; right:6px;
      font-size:11px;
      color:rgba(232,236,255,.55);
      letter-spacing:.12em;
      text-transform:uppercase;
    }
    #radar{
      width:160px; height:160px;
      border-radius:999px;
      border:1px solid rgba(75,125,255,.35);
      background:
        radial-gradient(circle at center, rgba(75,255,179,.09), rgba(11,15,26,.0) 60%),
        radial-gradient(circle at center, rgba(255,255,255,.06) 2px, rgba(0,0,0,0) 3px),
        radial-gradient(circle at center, rgba(255,255,255,.04) 38%, rgba(0,0,0,0) 40%),
        radial-gradient(circle at center, rgba(255,255,255,.03) 58%, rgba(0,0,0,0) 60%);
    }

    .wrap{
      width:min(980px,96vw);
      position:relative;
      z-index:5; /* sobre part√≠culas */
    }

    .card{
      width:min(560px,96vw);
      background:var(--card);
      padding:28px;
      border-radius:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      margin:0 auto;
      border:1px solid rgba(42,53,83,.5);
    }
    h1{font-size:22px;margin:0 0 12px;letter-spacing:.2px}
    p{opacity:.9;margin:0 0 10px;color:var(--muted)}
    input{
      width:85%;
      padding:14px 16px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--card2);
      color:var(--text);
      font-size:16px;
      outline:none;
    }
    button{
      width:100%;
      margin-top:12px;
      padding:12px 14px;
      border-radius:12px;
      border:0;
      background:var(--primary);
      color:#fff;
      font-size:16px;
      cursor:pointer;
    }
    button:hover{filter:brightness(1.05)}
    .msg{margin-top:12px;min-height:22px;color:var(--danger)}
    .hint{margin-top:12px;font-size:12px;opacity:.7;color:var(--muted)}

    /* Mensaje misi√≥n */
    .missionTitle{
      font-size:34px;
      line-height:1.05;
      margin:0 0 14px;
      letter-spacing:.2px;
    }
    .missionLead{
      font-size:18px;
      line-height:1.4;
      margin:0 0 10px;
      color:rgba(232,236,255,.85);
    }
    .missionBox{
      margin-top:14px;
      padding:14px 14px;
      border-radius:14px;
      border:1px solid rgba(42,53,83,.7);
      background:rgba(12,19,38,.75);
      color:rgba(232,236,255,.9);
    }
    .missionBox strong{color:#fff}

    /* Juego */
    #gameWrap{
      display:none;
      margin:18px auto 0;
      background:var(--card);
      border-radius:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      padding:18px;
      border:1px solid rgba(42,53,83,.5);
    }
    .gameTop{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .miniBtn{
      width:auto;margin:0;padding:10px 12px;border-radius:12px;
      background:transparent;border:1px solid var(--border);color:var(--text);cursor:pointer
    }
    .miniBtn:hover{background:rgba(12,19,38,.7)}

    .board{
      margin:14px auto 0;
      width:min(560px,96vw);
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(6,1fr);
      gap:10px;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }
    .cell{
      background:var(--card2);
      border:1px solid var(--border);
      border-radius:14px;
      position:relative;
      overflow:hidden
    }
    .dot{
      position:absolute;inset:0;margin:auto;width:18px;height:18px;border-radius:999px;
      box-shadow:0 0 0 4px rgba(255,255,255,.05);
      z-index:3
    }
    .dot.a{background:#ff4b6e}   /* rojo */
    .dot.b{background:#4bffb3}   /* verde */
    .dot.c{background:#4b7dff}   /* azul  */

    .path{
      position:absolute;inset:0;margin:auto;width:78%;height:78%;
      border-radius:14px;opacity:.22;z-index:2
    }
    .path.a{background:#ff4b6e}
    .path.b{background:#4bffb3}
    .path.c{background:#4b7dff}
  </style>
</head>
<body>

  <!-- Part√≠culas -->
  <canvas id="particles"></canvas>

  <!-- Radar -->
  <div id="radarWrap">
    <canvas id="radar" width="160" height="160"></canvas>
    <div id="radarLabel">RADAR</div>
  </div>

  <div class="wrap">

    <!-- 1) C√ìDIGO -->
    <div class="card" id="codeCard">
      <h1>C√≥digo de Agenteüïµüèª‚Äç‚ôÇÔ∏è</h1>
      <p>Ingresa el c√≥digo para continuar.</p>
      <input id="code" type="password" placeholder="C√≥digo" autocomplete="off" />
      <button id="btn">Entrar</button>
      <div class="msg" id="msg"></div>
      <div class="hint">Si aciertas, recibes una misi√≥n.</div>
    </div>

    <!-- 2) MENSAJE DE MISI√ìN -->
    <div class="card" id="missionCard" style="display:none;">
      <div class="missionTitle">‚úÖ Acceso concedido, agente</div>
      <div class="missionLead">Tu misi√≥n comienza ahora.</div>
      <div class="missionBox">
        <strong>Objetivo:</strong> conecta los puntos <strong>sin cruzar caminos</strong>.
        <div style="margin-top:8px; opacity:.85">Toca un punto y arrastra celda por celda.</div>
      </div>
      <button id="readyBtn" style="margin-top:16px;">Estoy listo</button>
      <div class="hint">Tip: si te equivocas, vuelve sobre tu camino para ‚Äúdeshacer‚Äù.</div>
    </div>

    <!-- 3) FLOW FREE 6x6 -->
    <div id="gameWrap">
      <div class="gameTop">
        <div>
          <div style="font-weight:700">Misi√≥n: conecta los 3 pares</div>
          <div class="hint" style="margin:6px 0 0">No puedes pasar por encima de puntos de otro color.</div>
        </div>
        <button class="miniBtn" id="resetBtn">Reiniciar</button>
      </div>

      <div class="board" id="board"></div>

      <div class="msg" id="gameMsg" style="color:var(--ok);margin-top:12px;min-height:22px"></div>
      <div class="hint">Al completar los 3 caminos, se abre el documento secreto.</div>
    </div>

  </div>

  <!-- Confetti overlay -->
  <canvas id="confetti" style="position:fixed; inset:0; width:100vw; height:100vh; pointer-events:none; z-index:9999; display:none;"></canvas>

  <script>
    // ‚úÖ C√≥digos v√°lidos
    const CODIGOS_VALIDOS = ["2201", "2095", "1883", "0001"];

    // ‚úÖ Pega aqu√≠ tu enlace de Google Drive
    const ENLACE_DRIVE = "https://drive.google.com/file/d/1cfL9S6FOY2NseUfphpPfO4r54i-hxTw0/view?usp=sharing";

    // ====== FLOW CONFIG ======
    const SIZE = 6;

    // Puzzle 6x6 (3 pares) - reto moderado.
    // Coordenadas 0-index (r,c).
    const pairs = {
      a: { start:[0,0], end:[3,2] }, // rojo
      b: { start:[0,5], end:[3,3] }, // verde
      c: { start:[5,1], end:[5,4] }, // azul
    };

    // ====== UI ======
    const codeCard = document.getElementById("codeCard");
    const missionCard = document.getElementById("missionCard");
    const readyBtn = document.getElementById("readyBtn");

    const input = document.getElementById("code");
    const msg = document.getElementById("msg");
    const btn = document.getElementById("btn");

    const gameWrap = document.getElementById("gameWrap");
    const board = document.getElementById("board");
    const resetBtn = document.getElementById("resetBtn");
    const gameMsg = document.getElementById("gameMsg");

    // ====== Abrir Drive grande ======
    function abrirDrivePantallaGrande(){
      const w = screen.width, h = screen.height;
      const features = `toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=${w},height=${h},top=0,left=0`;
      const win = window.open(ENLACE_DRIVE, "_blank", features);
      if (!win) window.location.href = ENLACE_DRIVE;
    }

    // ====== Pantallas ======
    function showMission(){
      codeCard.style.display = "none";
      missionCard.style.display = "block";
    }
    function showGame(){
      missionCard.style.display = "none";
      gameWrap.style.display = "block";
      buildBoard();
      resetGame();
    }

    // ====== Flow engine ======
    const key = (r,c)=>`${r},${c}`;
    const inBounds = (r,c)=>r>=0 && r<SIZE && c>=0 && c<SIZE;
    const isNeighbor = (a,b)=>Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1;

    function isEndpoint(color,r,c){
      const p=pairs[color];
      return (p.start[0]===r && p.start[1]===c) || (p.end[0]===r && p.end[1]===c);
    }
    function otherEndpoint(color,r,c){
      const p=pairs[color];
      if (p.start[0]===r && p.start[1]===c) return {r:p.end[0], c:p.end[1]};
      return {r:p.start[0], c:p.start[1]};
    }

    const occ = new Map();                 // cellKey -> color
    const paths = { a:[], b:[], c:[] };    // color -> [{r,c}]
    const done  = { a:false, b:false, c:false };

    let drawing=false, current=null, lastCell=null;

    function cellEl(r,c){
      const idx = r*SIZE + c;
      return board.children[idx];
    }

    function clearVisualPaths(){
      board.querySelectorAll(".path").forEach(el=>el.remove());
    }
    function renderPaths(){
      clearVisualPaths();
      for (const color of ["a","b","c"]) {
        for (const cell of paths[color]) {
          const el = cellEl(cell.r, cell.c);
          if (!el) continue;
          const p = document.createElement("div");
          p.className = `path ${color}`;
          el.appendChild(p);
        }
      }
    }

    function buildBoard(){
      board.innerHTML="";
      for (let r=0;r<SIZE;r++){
        for (let c=0;c<SIZE;c++){
          const cell=document.createElement("div");
          cell.className="cell";
          cell.dataset.r=r;
          cell.dataset.c=c;

          for (const color of ["a","b","c"]) {
            const p=pairs[color];
            if ((p.start[0]===r && p.start[1]===c) || (p.end[0]===r && p.end[1]===c)) {
              const d=document.createElement("div");
              d.className=`dot ${color}`;
              cell.appendChild(d);
            }
          }
          board.appendChild(cell);
        }
      }
    }

    function resetGame(){
      occ.clear();
      paths.a=[]; paths.b=[]; paths.c=[];
      done.a=false; done.b=false; done.c=false;
      drawing=false; current=null; lastCell=null;
      gameMsg.textContent="";
      renderPaths();
    }

    // ===== Confetti (sin librer√≠as) =====
    const confettiCanvas = document.getElementById("confetti");
    const cctx = confettiCanvas.getContext("2d");

    function resizeConfetti(){
      const dpr = window.devicePixelRatio || 1;
      confettiCanvas.width = Math.floor(window.innerWidth * dpr);
      confettiCanvas.height = Math.floor(window.innerHeight * dpr);
      cctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resizeConfetti);

    function launchConfetti(durationMs = 1400){
      resizeConfetti();
      confettiCanvas.style.display = "block";

      const W = window.innerWidth;
      const H = window.innerHeight;

      const pieces = [];
      const N = 140;
      const colors = ["#4b7dff", "#ff4b6e", "#4bffb3", "#ffd166", "#ffffff"];

      for (let i=0; i<N; i++){
        pieces.push({
          x: Math.random()*W,
          y: -20 - Math.random()*H*0.35,
          vx: (Math.random()-0.5)*6,
          vy: 3 + Math.random()*6,
          r: 3 + Math.random()*5,
          rot: Math.random()*Math.PI,
          vr: (Math.random()-0.5)*0.25,
          color: colors[(Math.random()*colors.length)|0],
          shape: Math.random() < 0.65 ? "rect" : "circle"
        });
      }

      const start = performance.now();
      function frame(t){
        const elapsed = t - start;
        cctx.clearRect(0,0,W,H);

        for (const p of pieces){
          p.vy += 0.06;
          p.x += p.vx;
          p.y += p.vy;
          p.rot += p.vr;

          if (p.x < -30) p.x = W + 30;
          if (p.x > W + 30) p.x = -30;

          cctx.save();
          cctx.translate(p.x, p.y);
          cctx.rotate(p.rot);
          cctx.fillStyle = p.color;

          if (p.shape === "rect"){
            cctx.fillRect(-p.r, -p.r, p.r*2, p.r*1.4);
          } else {
            cctx.beginPath();
            cctx.arc(0,0,p.r,0,Math.PI*2);
            cctx.fill();
          }
          cctx.restore();
        }

        if (elapsed < durationMs){
          requestAnimationFrame(frame);
        } else {
          cctx.clearRect(0,0,W,H);
          confettiCanvas.style.display = "none";
        }
      }

      requestAnimationFrame(frame);
    }

    function checkWin(){
      if (done.a && done.b && done.c) {
        gameMsg.textContent="¬°Completado! ‚úÖ";
        launchConfetti(1400);

        setTimeout(() => {
          gameMsg.textContent="Abriendo‚Ä¶";
          abrirDrivePantallaGrande();
        }, 900);
      }
    }

    function startDrawing(color, startCell){
      drawing=true; current=color; lastCell=startCell;

      for (const cell of paths[color]) occ.delete(key(cell.r,cell.c));
      paths[color]=[];
      done[color]=false;

      occ.set(key(startCell.r,startCell.c), color);
      paths[color].push(startCell);
      renderPaths();
    }

    function tryExtend(toCell){
      if(!drawing || !current || !lastCell) return;
      if(!inBounds(toCell.r,toCell.c)) return;
      if(!isNeighbor(lastCell,toCell)) return;

      const k = key(toCell.r,toCell.c);
      const occupiedBy = occ.get(k);

      if (occupiedBy && occupiedBy !== current) return;

      // no entrar en endpoints de otro color
      for (const other of ["a","b","c"]) {
        if (other!==current && isEndpoint(other,toCell.r,toCell.c)) return;
      }

      // recortar si vuelves sobre tu camino
      const idx = paths[current].findIndex(p=>p.r===toCell.r && p.c===toCell.c);
      if (idx !== -1) {
        const removed = paths[current].splice(idx+1);
        for (const cell of removed) occ.delete(key(cell.r,cell.c));
        lastCell = toCell;
        renderPaths();
        return;
      }

      // a√±adir
      occ.set(k,current);
      paths[current].push(toCell);
      lastCell = toCell;
      renderPaths();

      // ¬ølleg√≥ al destino?
      const start = paths[current][0];
      const target = otherEndpoint(current, start.r, start.c);
      if (toCell.r===target.r && toCell.c===target.c) {
        done[current]=true;
        drawing=false; current=null; lastCell=null;
        gameMsg.textContent="¬°Bien! Completa los otros colores.";
        checkWin();
      }
    }

    function endDrawing(){
      drawing=false; current=null; lastCell=null;
    }

    function cellFromPoint(x,y){
      const el = document.elementFromPoint(x,y);
      const cell = el && el.closest ? el.closest(".cell") : null;
      if (!cell) return null;
      return { r:Number(cell.dataset.r), c:Number(cell.dataset.c) };
    }

    board.addEventListener("pointerdown", (e)=>{
      const cell = cellFromPoint(e.clientX, e.clientY);
      if (!cell) return;

      for (const color of ["a","b","c"]) {
        if (isEndpoint(color, cell.r, cell.c)) {
          startDrawing(color, cell);
          board.setPointerCapture(e.pointerId);
          e.preventDefault();
          return;
        }
      }
    });

    board.addEventListener("pointermove", (e)=>{
      if (!drawing) return;
      const cell = cellFromPoint(e.clientX, e.clientY);
      if (!cell) return;
      tryExtend(cell);
      e.preventDefault();
    });

    board.addEventListener("pointerup", (e)=>{ endDrawing(); e.preventDefault(); });
    board.addEventListener("pointercancel", (e)=>{ endDrawing(); e.preventDefault(); });

    resetBtn.addEventListener("click", resetGame);

    // ====== C√≥digo ‚Üí Misi√≥n ‚Üí Juego ======
    function checkCode(){
      const code = input.value.trim();
      if (CODIGOS_VALIDOS.includes(code)) {
        msg.textContent = "";
        showMission();
      } else {
        msg.textContent = "C√≥digo incorrecto. Intente de nuevo.";
        input.value = "";
        input.focus();
      }
    }

    btn.addEventListener("click", checkCode);
    input.addEventListener("keydown",(e)=>{ if(e.key==="Enter") checkCode(); });
    readyBtn.addEventListener("click", showGame);

    // ====== Part√≠culas de fondo ======
    const pCanvas = document.getElementById("particles");
    const pctx = pCanvas.getContext("2d");
    let pW=0, pH=0, pDpr=1;
    const particles = [];
    const PCOUNT = 70;

    function resizeParticles(){
      pDpr = window.devicePixelRatio || 1;
      pW = window.innerWidth;
      pH = window.innerHeight;
      pCanvas.width = Math.floor(pW * pDpr);
      pCanvas.height = Math.floor(pH * pDpr);
      pctx.setTransform(pDpr,0,0,pDpr,0,0);
    }
    window.addEventListener("resize", resizeParticles);

    function initParticles(){
      particles.length = 0;
      for(let i=0;i<PCOUNT;i++){
        particles.push({
          x: Math.random()*pW,
          y: Math.random()*pH,
          r: 1 + Math.random()*2.2,
          vx: (Math.random()-0.5)*0.35,
          vy: (Math.random()-0.5)*0.35,
          a: 0.15 + Math.random()*0.35
        });
      }
    }

    function drawParticles(){
      pctx.clearRect(0,0,pW,pH);

      // puntos
      for(const p of particles){
        p.x += p.vx;
        p.y += p.vy;

        if (p.x < -10) p.x = pW + 10;
        if (p.x > pW + 10) p.x = -10;
        if (p.y < -10) p.y = pH + 10;
        if (p.y > pH + 10) p.y = -10;

        pctx.fillStyle = `rgba(232,236,255,${p.a})`;
        pctx.beginPath();
        pctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        pctx.fill();
      }

      // l√≠neas sutiles entre cercanos
      for(let i=0;i<particles.length;i++){
        for(let j=i+1;j<particles.length;j++){
          const a=particles[i], b=particles[j];
          const dx=a.x-b.x, dy=a.y-b.y;
          const dist=Math.hypot(dx,dy);
          if(dist < 120){
            const alpha = (1 - dist/120) * 0.18;
            pctx.strokeStyle = `rgba(75,125,255,${alpha})`;
            pctx.lineWidth = 1;
            pctx.beginPath();
            pctx.moveTo(a.x,a.y);
            pctx.lineTo(b.x,b.y);
            pctx.stroke();
          }
        }
      }

      requestAnimationFrame(drawParticles);
    }

    // ====== Radar animado ======
    const rCanvas = document.getElementById("radar");
    const rctx = rCanvas.getContext("2d");
    const RW = rCanvas.width;
    const RH = rCanvas.height;
    const R = RW/2;
    const blips = [
      { ang: 0.9,  rad: 0.55,  pulse: 0 },
      { ang: 2.2,  rad: 0.72,  pulse: 0.4 },
      { ang: 4.35, rad: 0.35,  pulse: 0.8 }
    ];
    let sweep = 0;

    function drawRadar(){
      rctx.clearRect(0,0,RW,RH);
      rctx.save();
      rctx.translate(R,R);

      // grid
      rctx.strokeStyle = "rgba(75,255,179,0.18)";
      rctx.lineWidth = 1;
      for(const rr of [0.25,0.5,0.75,1]){
        rctx.beginPath();
        rctx.arc(0,0, R*rr, 0, Math.PI*2);
        rctx.stroke();
      }
      // cruz
      rctx.beginPath(); rctx.moveTo(-R,0); rctx.lineTo(R,0); rctx.stroke();
      rctx.beginPath(); rctx.moveTo(0,-R); rctx.lineTo(0,R); rctx.stroke();

      // sweep
      sweep += 0.028;
      if (sweep > Math.PI*2) sweep = 0;

      const grad = rctx.createRadialGradient(0,0, 0, 0,0, R);
      grad.addColorStop(0, "rgba(75,255,179,0.16)");
      grad.addColorStop(1, "rgba(75,255,179,0.00)");

      rctx.fillStyle = grad;
      rctx.beginPath();
      rctx.moveTo(0,0);
      rctx.arc(0,0,R, sweep, sweep + 0.65);
      rctx.closePath();
      rctx.fill();

      // blips (peque√±os puntos)
      for (const b of blips){
        b.pulse += 0.03;
        const px = Math.cos(b.ang) * (R*b.rad);
        const py = Math.sin(b.ang) * (R*b.rad);

        const pulse = (Math.sin(b.pulse)+1)/2; // 0..1
        const size = 2.2 + pulse*2.2;

        rctx.fillStyle = `rgba(255,255,255,${0.45 + pulse*0.35})`;
        rctx.beginPath();
        rctx.arc(px,py,size,0,Math.PI*2);
        rctx.fill();
      }

      rctx.restore();
      requestAnimationFrame(drawRadar);
    }

    // init animations
    resizeParticles();
    initParticles();
    drawParticles();
    drawRadar();
  </script>
</body>
</html>
