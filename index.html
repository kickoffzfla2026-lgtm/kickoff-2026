<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Acceso</title>
  <style>
    body{font-family:system-ui,sans-serif;display:flex;min-height:100vh;align-items:center;justify-content:center;background:#0b0f1a;color:#e8ecff;padding:24px}
    .wrap{width:min(980px,96vw)}
    .card{width:min(420px,92vw);background:#121a2b;padding:24px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);margin:0 auto}
    h1{font-size:20px;margin:0 0 12px}
    p{opacity:.85;margin:0 0 16px}
    input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #2a3553;background:#0c1326;color:#e8ecff;font-size:16px;outline:none}
    button{width:100%;margin-top:12px;padding:12px 14px;border-radius:12px;border:0;background:#4b7dff;color:#fff;font-size:16px;cursor:pointer}
    button:hover{filter:brightness(1.05)}
    .msg{margin-top:12px;min-height:22px;color:#ffb3b3}
    .hint{margin-top:12px;font-size:12px;opacity:.6}

    #gameWrap{display:none;margin:18px auto 0;background:#121a2b;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:18px}
    .gameTop{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .miniBtn{width:auto;margin:0;padding:10px 12px;border-radius:12px;background:transparent;border:1px solid #2a3553;color:#e8ecff;cursor:pointer}
    .miniBtn:hover{background:#0c1326}

    .board{
      margin:14px auto 0;
      width:min(460px,92vw);
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(5,1fr);
      gap:10px;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }
    .cell{background:#0c1326;border:1px solid #2a3553;border-radius:14px;position:relative;overflow:hidden}
    .dot{position:absolute;inset:0;margin:auto;width:18px;height:18px;border-radius:999px;box-shadow:0 0 0 4px rgba(255,255,255,.05);z-index:3}
    .dot.a{background:#ff4b6e}   /* rojo */
    .dot.b{background:#4bffb3}   /* verde */
    .dot.c{background:#4b7dff}   /* azul  */
    .path{position:absolute;inset:0;margin:auto;width:78%;height:78%;border-radius:14px;opacity:.28;z-index:2}
    .path.a{background:#ff4b6e}
    .path.b{background:#4bffb3}
    .path.c{background:#4b7dff}
  </style>
</head>
<body>
  <div class="wrap">

    <!-- Paso 1: C√≥digo -->
    <div class="card" id="codeCard">
      <h1>C√≥digo de Agenteüïµüèª‚Äç‚ôÇÔ∏è</h1>
      <p>Ingresa el c√≥digo para continuar.</p>
      <input id="code" type="password" placeholder="C√≥digo" autocomplete="off" />
      <button id="btn">Entrar</button>
      <div class="msg" id="msg"></div>
      <div class="hint">Si aciertas, aparece el mini-juego.</div>
    </div>

    <!-- Paso 2: Juego -->
    <div id="gameWrap">
      <div class="gameTop">
        <div>
          <div style="font-weight:600">Conecta los 3 pares</div>
          <div class="hint" style="margin:6px 0 0">Toca un punto y arrastra. No cruces otros colores.</div>
        </div>
        <button class="miniBtn" id="resetBtn">Reiniciar</button>
      </div>

      <div class="board" id="board"></div>

      <div class="msg" id="gameMsg" style="color:#b7ffc9;margin-top:12px;min-height:22px"></div>
      <div class="hint">Completa los 3 caminos para abrir el enlace de Drive.</div>
    </div>

  </div>

  <script>
    // ‚úÖ C√≥digos v√°lidos
    const CODIGOS_VALIDOS = ["2201", "2095", "1883", "0001"];

    // ‚úÖ Pega aqu√≠ tu enlace de Google Drive (ideal: "Cualquiera con el enlace puede ver")
    const ENLACE_DRIVE = "PEGA_AQUI_TU_LINK_DE_DRIVE";

    const SIZE = 5;

    // Puzzle "medio": hace pensar pero no frustra
    const pairs = {
      a: { start:[0,1], end:[3,0] }, // rojo
      b: { start:[0,3], end:[3,4] }, // verde
      c: { start:[4,1], end:[4,3] }, // azul
    };

    // ====== ELEMENTOS ======
    const codeCard = document.getElementById("codeCard");
    const input = document.getElementById("code");
    const msg = document.getElementById("msg");
    const btn = document.getElementById("btn");

    const gameWrap = document.getElementById("gameWrap");
    const board = document.getElementById("board");
    const resetBtn = document.getElementById("resetBtn");
    const gameMsg = document.getElementById("gameMsg");

    // ====== UTIL ======
    const key = (r,c)=>`${r},${c}`;
    const inBounds = (r,c)=>r>=0 && r<SIZE && c>=0 && c<SIZE;
    const isNeighbor = (a,b)=>Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1;

    function isEndpoint(color,r,c){
      const p=pairs[color];
      return (p.start[0]===r && p.start[1]===c) || (p.end[0]===r && p.end[1]===c);
    }
    function otherEndpoint(color,r,c){
      const p=pairs[color];
      if (p.start[0]===r && p.start[1]===c) return {r:p.end[0], c:p.end[1]};
      return {r:p.start[0], c:p.start[1]};
    }

    // ====== ESTADO ======
    const occ = new Map();           // cellKey -> color
    const paths = { a:[], b:[], c:[] };
    const done  = { a:false, b:false, c:false };

    let drawing=false, current=null, lastCell=null;

    function cellEl(r,c){
      const idx = r*SIZE + c;
      return board.children[idx];
    }

    function clearVisualPaths(){
      board.querySelectorAll(".path").forEach(el=>el.remove());
    }
    function renderPaths(){
      clearVisualPaths();
      for (const color of ["a","b","c"]) {
        for (const cell of paths[color]) {
          const el = cellEl(cell.r, cell.c);
          if (!el) continue;
          const p = document.createElement("div");
          p.className = `path ${color}`;
          el.appendChild(p);
        }
      }
    }

    function buildBoard(){
      board.innerHTML="";
      for (let r=0;r<SIZE;r++){
        for (let c=0;c<SIZE;c++){
          const cell=document.createElement("div");
          cell.className="cell";
          cell.dataset.r=r;
          cell.dataset.c=c;

          for (const color of ["a","b","c"]) {
            const p=pairs[color];
            if ((p.start[0]===r && p.start[1]===c) || (p.end[0]===r && p.end[1]===c)) {
              const d=document.createElement("div");
              d.className=`dot ${color}`;
              cell.appendChild(d);
            }
          }
          board.appendChild(cell);
        }
      }
    }

    function resetGame(){
      occ.clear();
      paths.a=[]; paths.b=[]; paths.c=[];
      done.a=false; done.b=false; done.c=false;
      drawing=false; current=null; lastCell=null;
      gameMsg.textContent="";
      renderPaths();
    }

    function showGame(){
      codeCard.style.display="none";
      gameWrap.style.display="block";
      buildBoard();
      resetGame();
    }

    function abrirDrivePantallaGrande(){
      const w = screen.width, h = screen.height;
      const features = `toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=${w},height=${h},top=0,left=0`;
      const win = window.open(ENLACE_DRIVE, "_blank", features);
      if (!win) window.location.href = ENLACE_DRIVE; // si bloquea pop-up
    }

    function checkWin(){
      if (done.a && done.b && done.c) {
        gameMsg.style.color="#b7ffc9";
        gameMsg.textContent="¬°Completado! ‚úÖ Abriendo‚Ä¶";
        abrirDrivePantallaGrande();
      }
    }

    function startDrawing(color, startCell){
      drawing=true; current=color; lastCell=startCell;

      // borrar camino previo de ese color
      for (const cell of paths[color]) occ.delete(key(cell.r,cell.c));
      paths[color]=[];
      done[color]=false;

      occ.set(key(startCell.r,startCell.c), color);
      paths[color].push(startCell);
      renderPaths();
    }

    function tryExtend(toCell){
      if(!drawing || !current || !lastCell) return;
      if(!inBounds(toCell.r,toCell.c)) return;
      if(!isNeighbor(lastCell,toCell)) return;

      const k = key(toCell.r,toCell.c);
      const occupiedBy = occ.get(k);

      // no entrar en celdas ocupadas por otro color
      if (occupiedBy && occupiedBy !== current) return;

      // no entrar en endpoints de otro color
      for (const other of ["a","b","c"]) {
        if (other!==current && isEndpoint(other,toCell.r,toCell.c)) return;
      }

      // recorte si vuelves sobre tu camino
      const idx = paths[current].findIndex(p=>p.r===toCell.r && p.c===toCell.c);
      if (idx !== -1) {
        const removed = paths[current].splice(idx+1);
        for (const cell of removed) occ.delete(key(cell.r,cell.c));
        lastCell = toCell;
        renderPaths();
        return;
      }

      // a√±adir
      occ.set(k,current);
      paths[current].push(toCell);
      lastCell = toCell;
      renderPaths();

      // ¬ølleg√≥ a destino?
      const start = paths[current][0];
      const target = otherEndpoint(current, start.r, start.c);
      if (toCell.r===target.r && toCell.c===target.c) {
        done[current]=true;
        drawing=false; current=null; lastCell=null;
        gameMsg.style.color="#b7ffc9";
        gameMsg.textContent="¬°Bien! Completa los otros colores.";
        checkWin();
      }
    }

    function endDrawing(){
      drawing=false; current=null; lastCell=null;
    }

    // arrastre s√≥lido: detecta celda bajo el puntero
    function cellFromPoint(x,y){
      const el = document.elementFromPoint(x,y);
      const cell = el && el.closest ? el.closest(".cell") : null;
      if (!cell) return null;
      return { r:Number(cell.dataset.r), c:Number(cell.dataset.c) };
    }

    board.addEventListener("pointerdown", (e)=>{
      const cell = cellFromPoint(e.clientX, e.clientY);
      if (!cell) return;

      for (const color of ["a","b","c"]) {
        if (isEndpoint(color, cell.r, cell.c)) {
          startDrawing(color, cell);
          board.setPointerCapture(e.pointerId);
          e.preventDefault();
          return;
        }
      }
    });

    board.addEventListener("pointermove", (e)=>{
      if (!drawing) return;
      const cell = cellFromPoint(e.clientX, e.clientY);
      if (!cell) return;
      tryExtend(cell);
      e.preventDefault();
    });

    board.addEventListener("pointerup", (e)=>{ endDrawing(); e.preventDefault(); });
    board.addEventListener("pointercancel", (e)=>{ endDrawing(); e.preventDefault(); });

    resetBtn.addEventListener("click", resetGame);

    // C√≥digo
    function checkCode(){
      const code = input.value.trim();
      if (CODIGOS_VALIDOS.includes(code)) {
        msg.textContent="";
        showGame();
      } else {
        msg.textContent="C√≥digo incorrecto. Intente de nuevo.";
        input.value="";
        input.focus();
      }
    }
    btn.addEventListener("click", checkCode);
    input.addEventListener("keydown",(e)=>{ if(e.key==="Enter") checkCode(); });
  </script>
</body>
</html>
